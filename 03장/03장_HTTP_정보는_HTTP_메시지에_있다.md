# 3.1 HTTP 메시지

HTTP 에서 교환하는 정보

＞ 리퀘스트 측 HTTP 메시지 : 리퀘스트 메시지  
＞ 리스폰스 측 HTTP 메시지 : 리스폰스 메시지

## 구조

＞ 메시지 헤더

＞ 개행문자[CR+LF]

＞ 메시지 바디

### 메시지 헤더

서버와 클라이언트가 꼭 처리해야 하는 리퀘스트와 리스폰스 내용과 속성 등

### CR+LF

CR(carriage return) : 16진수 0x0d

LF(line feed) : 16진수 0x0a

### 메시지 바디

꼭 전송되는 데이터 그 자체

<img width="604" alt="스크린샷 2022-04-28 오전 10 59 10" src="https://user-images.githubusercontent.com/69156709/165661228-edffb84b-13bc-44af-8da2-0b195fbb7a15.png">

---

# 3.2 리퀘스트 메시지와 리스폰스 메시지의 구조

## 리퀘스트 & 리스폰스 메세지 공통

### 헤더 필드

＞ 리퀘스트/리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드 포함

＞ 일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더 필드, 엔티티 헤더 필드 4가지!

### 그 외

HTTP의 RFC에 없는 헤더 필드(쿠키 등)가 포함

## 리퀘스트 메시지 구조

<img width="604" alt="스크린샷 2022-04-28 오전 11 01 09" src="https://user-images.githubusercontent.com/69156709/165661432-e4557aa4-0b9c-4596-aa23-1c3914283fc5.png">

### 리퀘스트 라인

＞ 리퀘스트에 사용하는 메소드

＞ 리퀘스트 URI

＞ 사용하는 HTTP 버전

<details>
<summary>리퀘스트 메시지 예시</summary>
<img width="604" alt="스크린샷 2022-04-28 오전 11 28 21" src="https://user-images.githubusercontent.com/69156709/165664425-7e1ee383-4b0d-4a56-ba98-f0ef080bc6dc.png">
</details>

## 리스폰스 메시지 구조

<img width="604" alt="스크린샷 2022-04-28 오전 11 02 20" src="https://user-images.githubusercontent.com/69156709/165661534-8e832117-5c94-4fe7-b26c-5368e7ff6029.png">

### 상태 라인

＞ 리스폰스 결과를 나타내는 상태 코드와 설명

＞ 사용하는 HTTP 버전

<details>
<summary>리퀘스트 메시지 예시</summary>
<img width="604" alt="스크린샷 2022-04-28 오전 11 30 50" src="https://user-images.githubusercontent.com/69156709/165664644-74c46e41-42e5-44b1-a725-df0cfa1ba867.png">
</details>

---

# 3.3 전송 효율을 높이는 인코딩

＞ 장점 : 다량의 액세스를 효율 좋게 처리

＞ 단점 : 컴퓨터에서 인코딩 처리를 해야 하기 때문에 CPU 등의 리소스는 보다 많이 소비

## 메시지 바디와 엔티티 바디

### 메시지(message)

＞ HTTP 통신의 기본 단위

＞ 8비트 시퀀스로 구성

＞ 통신을 통해 전송

### 엔티티(entity)

＞ 리퀘스트/리스폰스의 부가물로 전송되는 정보

＞ 엔티티 헤더 필드와 엔티티 바디로 구성

### ❓ 메시지 == 엔티티 ❓

＞ HTTP 메시지 바디의 역할 = 리퀘스트/리스폰스 에 관한 엔티티 바디를 운반하는 일

＞ 기본적으로 메시지 바디와 엔티티 바디는 같음

＞ ❗️ `전송 코딩`이 적용된 경우 엔티티 바디의 내용이 변화

＞ 🌟 엔티티 바디와 메시지 바디가 달라짐

## 압축해서 보내는 `콘텐츠 코딩`

＞ 메일 첨부 파일의 용량을 줄이기 위해 파일을 압축하고 첨부해 보내는 것과 같음

＞ 엔티티 정보를 유지한 채로 압축

＞ 콘텐츠 코딩된 엔티티를 수신한 클라이언트 측에서 디코딩 함

### 주요 콘텐츠 압축

- gzip(GNU zip)
- compress(UNIX의 표준 압축)
- default(zlib)
- identity(인코딩 없음)

## 분해해서 보내는 `청크 전송 코딩`

＞ 엔티티 바디를 분할하는 기능

＞ 사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해 조금씩 표시

### 과정

- 엔티티 바디를 청크(덩어리)로 분해
- 청크 사이즈를 16진수로 사용해 단락을 표시
- 엔티티 바디 끝에 `0(CR+LF)`를 기록해둠
- 수신한 클라이언트 측에서 원래의 엔티티 바디로 디코딩

---

# 3.4 여러 데이터를 보내는 멀티파트

＞ 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있음

＞ 주로 이미지나 텍스트 파일 등을 업로드할 때 사용

## multipart/form-data

Web 폼으로부터 파일 업로드에 사용

## multipart/byteranges

상태 코드 206(Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용

---

# 3.5 일부분만 받는 레인지 리퀘스트

## 필요성

과거 : 광대역 네트워크를 이용할 수 없었음

다운로드 중 커넥션이 끊어지면 처음부터 다시 다운로드를 해야 함

＞ 대용량의 이미지와 데이터를 다운로드하기 힘들었음

＞ **리줌(resume)** 이라는 기능이 필요하게 됨 (이전에 다운로드 한 곳부터 다운로드 재개)

＞ 범위를 지정하여 리퀘스트 하는 **레인지 리퀘스트(Range Request)** 가 필요하게 됨

## 사용

### 범위 지정

Range 헤더 필드를 사용해 리소스의 바이트 레인지를 지정

ex) 5001~10000 바이트

```
Range: bytes = 5001-10000
```

### 리스폰스

＞ 상태코드 206 Partial Content 라는 리스폰스 메시지가 되돌아옴

＞ 복수 범위의 레인지 리퀘스드의 경우 multipart/byteranges 로 리스폰스가 되돌아옴

＞ 서버가 레인지 리퀘스트를 지원하지 않는 경우 상태코드 200 OK 라는 리스폰스 메시지로 완전한 엔티티가 되돌아옴

---

# 3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션

＞ 같은 콘텐츠이지만 여러 개의 페이지를 지낸 웹 페이지에서 사용 (ex. 영어판, 한국어판 구글)

＞ 클라이언트와 서버가 제공하는 리소스의 내용에 대해 교섭하는 것

＞ 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조

## 판단 기준 (다음 장 참고)

리퀘스트 메시지에 포함된 리퀘스트 헤더 필드

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

### 서버 구동형 네고시에이션

＞ 서버 측에서 콘텐츠 네고시에이션

＞ 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리

＞ 브라우저가 보내는 정보를 근거로 하기 때문에 유저에게 정말 적절한 것인지 모름

### 에이전트 구동형 네고시에이션

＞ 클라이언트 측에서 콘텐츠 네고시에이션

＞ 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택

＞ JavaScript 등을 사용해서 웹 페이지에 자동적으로 정하는 방법도 있음

### 트랜스페어런트 네고시에이션

＞ 서버 구동형과 에이전트 구동형을 혼합한 것

＞ 서버와 클라이언트가 각각 콘텐츠 네고시에이션
