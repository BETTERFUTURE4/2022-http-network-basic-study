# 2장 간단한 프로토콜 HTTP
## HTTP는 클라이언트와 서버 간에 통신을 한다.
**HTTP도 다른 TCP/IP 프로토콜처럼 클라이언트 - 서버 통신을 한다!**  

HTTP 통신 시에는 반드시 한 쪽은 클라이언트, 다른 한 쪽은 서버가 되는데, 텍스트, 이미지 등 리소스를 요청하는 쪽이 클라이언트, 요청을 받아 해당 리소스를 제공해주는 쪽이 서버가 된다.

## Request와 Response의 교환
- Request: 클라이언트가 서버에 요청  
- Response: 서버가 클라이언트에 응답  
  - 반드시 Request가 있어야 Response가 만들어질 수 있음

### Request와 Response의 구조
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4g6c8%2FbtqJRmEIaA9%2F7eygSadanLoc5FmWCwGZPK%2Fimg.png)  
이미지 출처: https://deepwelloper.tistory.com/98

### ex) Request와 Response 예시

Request
```
GET /index.html HTTP /1.1
Host: https://github.com/woowacourse-study/2022-http-network-basic-study
```

Response
```
HTTP/1.1 200 OK
Date: Sat, 23 Apr 2022 08:09:05 GMT
Content-Type: text/html; charset=utf-8

<html>
...
```

클라이언트가 서버로 보내는 리퀘스트 메시지는 메서드, URI, 프로토콜 버전, 옵션 리퀘스트 헤더 필드와 엔티티로 구성이 된다.

맨 윗줄의 요청라인(또는 상태라인)은 메서드, URI, 프로토콜 버전을 포함하는데, `GET`과 같은 서버로의 요청 종류를 메서드라고 한다. `/index.html`은 요구 대상인 리소스를 나타내며, 이를 Request URI라고 한다. `HTTP/1.1`은 서버가 클라이언트 기능을 식별하기 위한 HTTP 버전을 나타낸다. (리퀘스트 헤더 필드와 엔티티는 추후 설명)

`Host: https://github.com/woowacourse-study/2022-http-network-basic-study`부분은 헤더에 포함되며, 요청하려는 서버의 호스트 이름과 포트 번호를 나타낸다. 위 예시에는 리퀘스트 바디는 포함되어 있지 않다.

클라이언트가 서버로 리퀘스트를 보내고 나면 서버는 해당 요청 내용을 처리한 뒤 클라이언트로 리스폰스를 되돌려준다.

리스폰스 메시지 역시 리퀘스트와 비슷한 구조로 구성되어 있는데,  프로토콜 버전, 상태 코드와 상태 코드에 대한 설명, 옵션의 리스폰스 헤더 필드와 바디로 구성되어 있다. 리퀘스트와 마찬가지로 맨 윗줄의 요청라인이 메서드, URI, 프로토콜 버전을 포함하며, 추가로 상태 코드와 상태 코드에 대한 설명이 들어간다.

위 예시에서는 `HTTP/1.1`이 프로토콜 버전을, `200 OK`가 상태 코드와 상태 코드에 대한 설명을 나타내며, 그 아래 헤더에는 Date와 Content-Type 등의 정보가 들어간다. 헤더 아래에 한 줄 공백 이후부터는 리스폰스 바디가 시작된다.

## HTTP는 Stateless하다.
HTTP는 상태를 유지하지 않는 stateless 프로토콜이다. HTTP 통신을 통해 리퀘스트와 리스폰스를 교환하기는 하지만, 그 동안에 HTTP 프로토콜 자체적으로 상태(status)를 저장하지는 않는다.

상태를 기억하지 않기 때문에, HTTP 프로토콜은 이전에 보냈던 리퀘스트나 이미 돌려준 리스폰스 정보를 전혀 기억할 수 없으며, 새 리퀘스트가 보내지면 새로운 리스폰스가 생성된다. 이는 **많은 데이터를 매우 빠르고 확실하게 처리하기 위함(범위성)이다.**

하지만 웹의 진화에 따라 로그인 기능과 같이 상태를 저장하고 유지할 필요가 생기게 되면서 쿠키(Cookie)라는 기술이 도입되었다.

## HTTP는 Request URI를 통해 리소스를 식별한다.
HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정한다. 이를 통해 인터넷 상에 있는 어떤 리소스라도 호출할 수 있다.

### 여기서 잠깐, URI란?  
URI(Uniform Resource Identifiers)란 특정 리소스를 식별하는 **통합 자원 식별자**를 의미하며, 인터넷에 있는 자원을 나타내는 유일한 주소이다. URI의 존재는 인터넷에서 요구되는 기본조건으로서 인터넷 프로토콜에 항상 붙어 다닌다.

흔히 URL(Uniform Resource Locatior)과 헷갈리거나 혼용해서 사용하는 경향이 있는데, URI는 자원을 나타내는 유일한 주소를, URL은 네트워크에 자원이 어디에 있는지 알려주기 위한 규약을 의미한다.

URL은 URI에 포함되는 하위 개념으로, URI에는 URL 뿐 아니라 URN(Uniform Resource Name)이라는 것도 존재한다.

우리가 일반적으로 URL이라고 부르는 많은 부분들은 사실 URI라고 불러야 정확한 경우가 많다. 예를 들어

`https://search.naver.com/search.naver?where=nexearch&sm=top_sug.pre&fbm=0&acr=1&acq=U&qdt=0&ie=utf8&query=URL` 와 같은 주소가 있다고 하면, `https://serach.naver.com/serch.naver` 까지는 자원의 위치를 나타내는 URL이 맞지만, 뒤의 `?where=nexearch&sm=top_sug.pre&fbm=0&acr=1&acq=U&qdt=0&ie=utf8&query=URL` 부분은 자원을 식별해주는 식별자를 나타내기 때문에 URL이라고 볼 수 없기 때문이다.

다시 리퀘스트 URI로 돌아와서, 리퀘스트를 송신할 때는 리퀘스트에 URI를 리퀘스트 URI라 불리는 형식으로 포함해야 한다. 리퀘스트 URI를 지정하는 방법은 여러 가지가 있는데,
- 모든 URI를 리퀘스트 URI에 포함한다.
```
GET http://study.com/index.html HTTP/1.1
```
- Host 헤더 필드에 네트워크 로케이션을 포함한다.
```
GET /index.html HTTP/1.1
Host: study.com
```
위 두 예시 모두 `http://study.com/index.html`을 리퀘스트 하는 경우이다.

이외에도 특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우, HTTP 서버가 지원하고 있는 메서드를 묻는 다음 예시와 같이 와일드카드(*)를 사용할 수 있다.
```
OPTIONS * HTTP/1.1
```

## HTTP 메서드

HTTP 메서드란 `클라이언트가 웹 서버에게 요청의 목적 및 종류를 알리는 수단`으로, 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재한다.

**HTTP/1.0과 HTTP/1.1에서 지원하고 있는 메서드**
|메서드 명|설명|제공하고 있는 HTTP 버전|리퀘스트 바디|리스폰스 바디|안전|멱등|캐시|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|GET|리소스 취득|1.0 1.1|X|O|O|O|가능|
|POST|엔티티 바디 전송|1.0 1.1|O|O|X|X|가능|
|PUT|파일 전송 / 내용 갱신|1.0 1.1|O|O|X|O|불가능|
|PATCH|자원 수정|1.1|O|O|X|X|가능|
|HEAD|메시지 헤더 취득|1.0 1.1|X|X|O|O|가능|
|DELETE|파일 삭제|1.0 1.1|X|O|X|O|불가능|
|OPTIONS|서포트하고 있는 메서드 문의|1.1|선택|O|O|O|불가능|
|TRACE|경로 조사|1.1|X|O|O|O|불가능|
|CONNECT|프록시에의 터널링 요구|1.1|O|O|X|X|불가능|
|LINK|리소스 간에 링크 관계를 확립|1.0|X|X|X|O|불가능|
|UNLINK|링크 관계 삭제|1.0|X|X|X|O|불가능|

### GET: 리소스 획득
GET 메서드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다.

GET 메서드는 캐싱이 가능하여, 최초 리소스를 요청할 때는 요청만 하고, 이후 요청 때는 첫 요청의 응답에 함께 온 HTTP 헤더 정보를 참고하여 변경사항이 있는지 물어보는 GET을 사용하기도 하는데, 이를 `Conditional GET` 이라고 한다. 보통 Last-modified, eTag 등의 헤더 정보를 참고한다.

### POST: 엔티티 전송
POST 메서드는 엔티티를 전송하기 위해서 사용된다. GET으로도 엔티티를 전송할 수 있지만, 보통 POST를 사용한다. POST 시에는 요청 데이터를 HTTP 바디에 담아 전송한다. 만약 요청된 리소스가 새로 작성된 경우, 서버에서 리스폰스를 돌려줄 때 헤더에 `Location`으로 URI를 포함한 201 Created 리스폰스를 보내야 한다.

### PUT: 파일 전송 / 내용 갱신
PUT 메서드는 파일을 전송하기 위해서(책의 설명) 또는 대상 리소스의 상태가 생성되거나 요청 메시지 페이로드에 포함된 표현에 의해 정의된 상태로 대체 되도록 요청한다(공식 문서). 

PUT 메서드는 FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI에 저장하도록 요구한다. 때문에 PUT 리퀘스트를 서버에서 리스폰스로 돌려줄 때는 POST와 다르게 HTTP 헤더에 `Location`을 명시하지 않아도 된다. (클라이언트가 제시한 URI를 그대로 사용하는 것으로 간주)

단, HTTP/1.1 PUT은 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제로 일반적인 웹 사이트에서는 파일 업로드의 형태로 사용되지 않고, RESTful한 API 설계와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용한다.

대상 리소스에 현재 데이터가 없고 PUT이 성공적으로 데이터를 생성하면 원 서버는 201 Created 응답을 전송하며, 이미 데이터가 있고 PUT에 의해 성공적으로 수정된다면 200 OK 또는 204 No Content 리스폰스를 보낸다.

### PATCH: 파일 수정
PATCH 메서드는 리소스에 부분 수정을 적용하는데 사용된다. PUT과 비슷하나, PUT은 리소스의 모든 것을 업데이트 하지만 PATCH는 일부를 업데이트 한다는 점에서 차이가 있다. 즉, PATCH 요청을 하면 보내지 않은 데이터는 수정되지 않고 그대로 유지된다. (PUT의 경우 보내지 않은 데이터가 있으면 그 부분이 사라진다.) 또한 PATCH는 PUT과 다르게 새로운 자원을 생성하지 않는다. 마지막으로 PUT은 멱등성을 보장하지만 PATCH는 멱등성을 보장하지 않는다.

### 여기서 잠깐, 멱등성이란?
> An HTTP method is idempotent if an identical request can be made once or several times in a row with the same effect while leaving the server in the same state.  
>
>동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말한다.

즉, 서버에 요청을 한 번 날리나 여러 번 날리나 같은 결과를 보장할 때 멱등성을 가지고 있다고 할 수 있다.

그렇다면 PUT은 멱등인데 왜 PATCH는 멱등이 아닐까? 정확히 말하면 PATCH가 멱등이 아닌 것이 아니라 `멱등이 아니어도 된다.`라고 볼 수 있다. PUT은 리소스를 완전히 교체해 버리기 때문에 멱등성을 반드시 보장해야 하지만(멱등을 보장하지 않게 설계할 수도 있지만 이는 올바른 설계가 아니다.), PATCH는 설계에 따라 멱등이 아닐 수가 있다.

```
{
    name: "Ohzzi"
}
```
와 같은 PATCH 요청은 name 부분을 바꿔주므로 멱등이다. 하지만
```
{
    "operation": "add",
    "age": 10
}
```
이렇게 PATCH 요청이 설계되어 있다면, 이를 두 번 호출하면 +10 +10이어서 멱등이 아니게 된다.

멱등성과 같은 조건을 파악하는 것은 HTTP 메서드를 원래 목적에 맞게 사용하는 경우에 한정한다. 멱등성이 보장된다고 알려진 메서드들도 설계에 따라 멱등을 보장하지 않도록 설계할 수 있는데, 이는 올바르게 설계된 메서드가 아니다. 예를 들어 GET 메서드가 파라미터를 기반으로 데이터를 조회하는 용도가 아니라 생성 또는 변경하는 용도로 사용될 경우, 멱등성을 깰 수 있는데, 이는 원래 GET 메서드의 동작 의도가 아니므로 GET 메서드는 멱등성을 가진다고 하는 것이다.

[참고 자료](https://www.inflearn.com/questions/110644)

### HEAD: 메시지 헤더 취득
HEAD 메서드는 GET과 비슷하나, 실제 문서를 요청하는 것이 아니라 문서 정보를 요청한다. 때문에 GET에 대한 리스폰스는 바디를 가지지만 HEAD에 대한 리스폰스는 바디를 갖지 않고 헤더만 가지게 된다. HEAD 역시 GET처럼 리스폰스의 캐싱이 가능하다.

### DELETE: 파일 삭제
DELETE 메서드는 URI로 지정된 리소스의 삭제를 요구한다. DELETE 역시 PUT과 마찬가지로 인증 기능이 없다.

### OPTIONS

OPTIONS 메서드는 리퀘스트 URI가 제공하고 있는 메서드를 조회하기 위해 사용한다. 서버는 OPTIONS 요청을 받으면 리스폰스 헤더에 `Allow: GET, POST, HEAD, OPTIONS`와 같이 서버가 제공하고 있는 메서드를 담아서 돌려준다.

### TRACE
TRACE 메서드는 서버에 접속해서 자신에게 통신을 되돌려 받는데, 이를 루프백(loop-back)이라고 한다. 리퀘스트를 보낼 때에 "Max-Forwards"라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때 마다 그 수치를 줄여간다. 수치가 0이 된 곳을 끝으로, 리퀘스트를 마지막으로 수신한 곳에서 200 OK 리스폰스를 되돌려준다.

TRACE 메서드를 통해 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있는데, 프록시 서버 등을 통해 오리진(origin) 서버에 접속할 때 그 동작을 확인하기 위해 사용한다.

```
Request

TRACE / HTTP /1.1
Host: study.com
Max-Forwards: 2

Response

HTTP /1.1 200 OK
Content-Type: message/http
Content-Length: 1024

TRACE / HTTP /1.1
Host: study.com
Max-Forwards: 2 (리퀘스트 헤더 내용이 리스폰스 바디에 포함되어 반환된다.)
```

하지만 TRACE 메서드는 거의 사용되지 않으며, 크로스 사이트 트레이싱(XST)와 같은 공격이 가능한 보안 취약점이 있다. 

### CONNECT
CONNECT 메서드는 TCP 통신을 터널링 시키기 위해 사용한다. 주로 SSL과 TLS 등의 프로토콜로 암호화 된 것을 터널링 시키기 위해 사용된다.
`CONNECT 프록시 서버:포트 HTTP 버전` 의 형태로 사용한다.

### 여기서 잠깐, 터널링이란?
터널링은 두 노드 또는 두 네트워크 간에 가상의 링크를 형성하여 하나의 프로토콜이 다른 프로토콜을 감싸는 캡슐화 기능을 통해 데이터를 운반하는 기능을 말한다. 일반적으로 터널링 기법은 보안 채널의 역할을 한다.

## HTTP는 지속 연결을 통해 접속량을 절약한다.

HTTP 초기 버전에서는 한 번의 HTTP 통신 마다 TCP에 의해 연결 및 종료를 했다. 하지만 HTTP가 널리 보급되어 다량의 이미지를 포함한 문서 등이 늘어나면서 문제가 생겼다. 하나의 HTML에 여러 이미지가 포함되어 있는 경우, 브라우저를 통해 리퀘스트를 하면 HTML 문서에 포함되어 있는 이미지를 획득하기 위해 여러 리퀘스트를 보내게 되는데, 이 때 매번 TCP 연결 및 종료를 하면 통신량이 늘어난다.

때문에 HTTP/1.1 그리고 일부 HTTP/1.0에서는 지속 연결(Persistent Connections)라는 방법을 고안, 이는 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지하는 방식이다.

지속 연결을 통해 TCP 커넥션의 연결과 종료를 반복하는 오버헤드를 줄여 서버의 부하가 경감되고 리퀘스트와 리스폰스가 빨리 완료되어 웹 페이지의 로딩 시간을 단축할 수 있다.

지속 연결은 HTTP/1.1에서는 표준 동작이지만, HTTP/1.0 에서는 표준이 아니며, 서버와 클라이언트 모두가 지속 연결을 지원해야 사용이 가능하다.

### 파이프라인화
![](https://velog.velcdn.com/images/ohzzi/post/4cf26207-0740-40b1-8198-33d056a260a2/image.png)

지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 한다.(HTTP pipelining) 파이프라인화란 리퀘스트 하나를 송신 한 이후, 해당 리퀘스트에 대한 리스폰스를 기다리지 않고 다른 리퀘스트를 보낼 수 있도록 하는 것으로, 예를 들어 한 HTML 페이지에 10개의 이미지를 포함한다면 해당 이미지들의 대한 리퀘스트들을 리스폰스를 기다리지 않고 보내서 훨씬 더 빠르게 페이지를 로드할 수 있다. 리퀘스트의 수가 늘어날 수록 속도 차이는 더 현저하게 늘어난다.

다수의 리퀘스트들이 1개의 socket에 쓰여지고, 브라우저는 리퀘스트에 대한 리스폰스를 순차적으로 기다리는 메커니즘을 통해 작동한다.

파이프라인화는 `GET`, `HEAD`와 같이 멱등한 HTTP 메서드에 대해서만 작동할 수 있다.

## 쿠키를 통한 상태 관리

HTTP는 stateless한 프로토콜이지만, 인증 등의 이유로 상태를 저장해야 할 필요가 생기는 경우가 있다. 예를 들어 인증이 필요한 웹 페이지가 상태 관리를 하지 않을 경우, 페이지 이동 시마다 매번 로그인을 하거나 리퀘스트에 로그인 상태를 붙여서 처리해야 한다.

HTTP를 stateless하지 않게 만들면 해결되는 일이지만, HTTP는 stateless이기 때문에 서버의 리소스 소비를 억제한다는 장점이 있으며, 단순한 프로토콜이어서 여러 곳에서 사용된다는 점에서 stateless를 포기할 수는 없다.

때문에 이러한 특징은 남겨 둔 채 상태 관리 문제를 해결하기 위해 쿠키가 도입되었다. 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하는 시스템으로, 서버에서 리스폰스로 `Set-Cookie` 헤더 필드에 쿠키를 담아서 보내게 되면 클라이언트가 이를 보존하고, 클라이언트가 같은 서버로 리퀘스트를 보낼 때 보존된 쿠키 값을 담는 방식으로 작동한다. 이 리퀘스트를 서버가 받으면 쿠키를 확인해서 어떤 클라이언트가 접속했는지 확인하고, 서버 내의 기록을 확인해서 이전 상태를 불러오게 된다.

쿠키를 사용한 리퀘스트 / 리스폰스 방식을 다시 정리하자면,
1. 클라이언트는 쿠키를 담지 않은 리퀘스트를 보낸다.(최초 인증)
2. 서버는 쿠키를 발행하여 리스폰스로 돌려준다.
3. 클라이언트는 해당 쿠키를 받아 이후의 리퀘스트에 자동으로 쿠키를 담아서 보낸다.
